Index: src/solvers/flattening/arrays.cpp
===================================================================
--- src/solvers/flattening/arrays.cpp	(revision 5264)
+++ src/solvers/flattening/arrays.cpp	(working copy)
@@ -11,6 +11,8 @@
 #include <cassert>
 #include <iostream>
 
+#include <langapi/language_util.h>
+
 #include <util/std_expr.h>
 #include <util/std_types.h>
 #include <util/arith_tools.h>
@@ -37,6 +39,8 @@
   const namespacet &_ns,
   propt &_prop):equalityt(_ns, _prop)
 {
+  lazy_arrays = false; 		// will be set to true when --refine is used
+  incremental_cache = true;	// used for the 2ls tool
 }
 
 /*******************************************************************\
@@ -51,8 +55,13 @@
 
 \*******************************************************************/
 
+
+
 void arrayst::record_array_index(const index_exprt &index)
 {
+  // we are not allowed to put the index directly in the
+  //   entry for the root of the equivalence class
+  //   because this map is accessed during building the error trace
   std::size_t number=arrays.number(index.array());
   index_map[number].insert(index.index());
 }
@@ -99,6 +108,51 @@
 
 /*******************************************************************\
 
+Function: arrayst::collect_indices
+
+  Inputs:
+
+ Outputs:
+
+ Purpose:
+
+\*******************************************************************/
+
+void arrayst::collect_indices()
+{
+  for(std::size_t i=0; i<arrays.size(); i++)
+  {
+    collect_indices(arrays[i]);
+  }
+}
+void arrayst::collect_indices(const exprt &expr)
+{
+  if(expr.id()!=ID_index)
+  {
+    forall_operands(op,expr) collect_indices(*op);
+  }
+  else
+  {
+    const index_exprt &e = to_index_expr(expr);
+    collect_indices(e.index()); //necessary?
+  
+    const typet &array_op_type=ns.follow(e.array().type());
+  
+    if(array_op_type.id()==ID_array)
+    {
+      const array_typet &array_type=
+	to_array_type(array_op_type);
+
+      if(is_unbounded_array(array_type))
+      {
+	record_array_index(e);
+      }
+    }
+  }
+}
+
+/*******************************************************************\
+
 Function: arrayst::collect_arrays
 
   Inputs:
@@ -233,6 +287,48 @@
 
 /*******************************************************************\
 
+Function: arrayst::add_array_constraint
+
+  Inputs:
+
+ Outputs:
+
+ Purpose: Lazily adding array constraints for the refinement loop.
+
+\*******************************************************************/
+
+
+void arrayst::add_array_constraint(const lazy_constraintt &lazy, bool refine)
+{
+  if (lazy_arrays)
+  {
+    // lazily add the constraint
+    if (incremental_cache)
+    {
+      if (expr_map.find(lazy.lazy) == expr_map.end()) {
+	if (!refine) prop.l_set_to_true(convert(lazy.lazy));
+	else
+	{
+	  lazy_array_constraints.push_back(lazy);
+	  expr_map[lazy.lazy] = true;
+	}
+      }
+    }
+    else
+    {
+      if (!refine) prop.l_set_to_true(convert(lazy.lazy));
+      else lazy_array_constraints.push_back(lazy);
+    }
+  }
+  else
+  {
+    // add the constraint eagerly
+    prop.l_set_to_true(convert(lazy.lazy));
+  }
+}
+
+/*******************************************************************\
+
 Function: arrayst::add_array_constraints
 
   Inputs:
@@ -245,29 +341,36 @@
 
 void arrayst::add_array_constraints()
 {
-  // first get index map
-  build_index_map();
-  
+  collect_indices();
+  // at this point all indices should in the index set
+    
+  // reduce initial index map
+  update_index_map();
+
   // add constraints for if, with, array_of
   for(std::size_t i=0; i<arrays.size(); i++)
   {
-    update_index_map();
-
     // take a copy as arrays may get modified by add_array_constraints
     // in case of nested unbounded arrays
     exprt a=arrays[i];
 
     add_array_constraints(index_map[arrays.find_number(i)], a);
+    update_index_map();
   }
 
   // add constraints for equalities
-  for(array_equalitiest::const_iterator it=
-      array_equalities.begin();
-      it!=array_equalities.end();
-      it++)
-    add_array_constraints(
-      index_map[arrays.find_number(it->f1)],
-      *it);
+      for(array_equalitiest::const_iterator it=
+          array_equalities.begin();
+          it!=array_equalities.end();
+          it++)
+      {
+
+    	add_array_constraints(
+          index_map[arrays.find_number(it->f1)],
+          *it);
+	
+        // update_index_map should not be necessary here
+      }
     
   // add the Ackermann constraints
   add_array_Ackermann_constraints();
@@ -305,10 +408,9 @@
           i2++)
         if(i1!=i2)
         {
-          // skip if both are constants
           if(i1->is_constant() && i2->is_constant())
             continue;
-        
+
           // index equality
           equal_exprt indices_equal(*i1, *i2);
 
@@ -318,78 +420,47 @@
             indices_equal.op1().
               make_typecast(indices_equal.op0().type());
           }
-          
-          literalt indices_equal_lit=convert(indices_equal);
-          
-          if(indices_equal_lit!=const_literal(false))
-          {
-            index_exprt index_expr1;
-            index_expr1.type()=ns.follow(arrays[i].type()).subtype();
-            index_expr1.array()=arrays[i];
-            index_expr1.index()=*i1;
 
-            index_exprt index_expr2=index_expr1;
-            index_expr2.index()=*i2;
+          index_exprt index_expr1;
+          index_expr1.type()=ns.follow(arrays[i].type()).subtype();
+          index_expr1.array()=arrays[i];
+          index_expr1.index()=*i1;
+
+          index_exprt index_expr2=index_expr1;
+          index_expr2.index()=*i2;
+
           
-            equal_exprt values_equal(index_expr1, index_expr2);
+          equal_exprt values_equal(index_expr1, index_expr2);
+          convert(values_equal);
 
-            prop.lcnf(!indices_equal_lit, convert(values_equal));
-          }
+          lazy_constraintt lazy(ARRAY_ACKERMANN, implies_exprt(indices_equal, values_equal));
+          add_array_constraint(lazy);
         }
   }
 }
 
 /*******************************************************************\
 
-Function: arrayst::build_index_map
-
-  Inputs:
-
- Outputs:
-
- Purpose:
-
-\*******************************************************************/
-
-void arrayst::build_index_map()
-{
-  // merge the indices into the root
-  
-  // iterate over non-roots
-  for(std::size_t i=0; i<arrays.size(); i++)
-  {
-    if(arrays.is_root_number(i)) continue;
-
-    std::size_t root_number=arrays.find_number(i);
-    assert(root_number!=i);
-
-    index_sett &root_index_set=index_map[root_number];
-    index_sett &index_set=index_map[i];
-
-    root_index_set.insert(index_set.begin(), index_set.end());
-  }
-}
-
-/*******************************************************************\
-
 Function: arrayst::update_index_map
 
   Inputs:
 
  Outputs:
 
- Purpose:
+ Purpose: merge the indices into the root
 
 \*******************************************************************/
 
 void arrayst::update_index_map()
 {
-  // merge the indices into the root
-  
-  const unsigned size_before=index_map.size();
-
   // iterate over non-roots
-  for(unsigned i=size_before; i<arrays.size(); i++)
+  // possible reasons why update is needed:
+  //  -- there are new equivalence classes in arrays
+  //  -- there are new indices for arrays that are not the root
+  //     of an equivalence class
+  //     (and we cannot do that in record_array_index())
+  //  -- equivalence classes have been merged
+  for(unsigned i=0; i<arrays.size(); i++)
   {
     if(arrays.is_root_number(i)) continue;
 
@@ -401,6 +472,22 @@
 
     root_index_set.insert(index_set.begin(), index_set.end());
   }
+
+#if 0
+  for(index_mapt::const_iterator
+        i1=index_map.begin();
+        i1!=index_map.end();
+        i1++)
+    for(index_sett::const_iterator
+        i2=i1->second.begin();
+        i2!=i1->second.end();
+        i2++)    std::cout << "Index set (" << i1->first << " = "
+		           << arrays.find_number(i1->first) << " = "
+			   << from_expr(ns,"",arrays[arrays.find_number(i1->first)]) << "): "
+			   << from_expr(ns,"",*i2) << std::endl;
+   std::cout << "-----" << std::endl;
+#endif
+
 }
 
 /*******************************************************************\
@@ -438,9 +525,15 @@
     
     assert(index_expr1.type()==index_expr2.type());
 
+    array_equalityt equal;
+    equal.f1 = index_expr1;
+    equal.f2 = index_expr2;
+    equal.l = array_equality.l;
     equal_exprt equality_expr(index_expr1, index_expr2);
     
     // add constraint
+    // equality constraints are not added lazily
+    // convert must be done to guarantee correct update of the index_set
     prop.lcnf(!array_equality.l, convert(equality_expr));
   }
 }  
@@ -510,7 +603,8 @@
       assert(index_expr1.type()==index_expr2.type());
 
       // add constraint
-      set_to(equal_exprt(index_expr1, index_expr2), true);
+      lazy_constraintt lazy(ARRAY_TYPECAST, equal_exprt(index_expr1, index_expr2));
+      add_array_constraint(lazy, false);
     }
   }
   else if(expr.id()==ID_index)
@@ -537,7 +631,7 @@
   const with_exprt &expr)
 {
   // we got x=(y with [i:=v])
-  // add constaint x[i]=v
+  // add constraint x[i]=v
 
   const exprt &index=expr.where();
   const exprt &value=expr.new_value();
@@ -554,7 +648,8 @@
       assert(false);
     }
 
-    set_to_true(equal_exprt(index_expr, value));
+     lazy_constraintt lazy(ARRAY_WIDTH, equal_exprt(index_expr, value));
+     add_array_constraint(lazy,false);
   }
 
   // use other array index applications for "else" case
@@ -574,10 +669,6 @@
       if(other_index.type()!=index.type())
         other_index.make_typecast(index.type());
 
-      literalt guard_lit=convert(equal_exprt(index, other_index));
-
-      if(guard_lit!=const_literal(true))
-      {
         index_exprt index_expr1;
         index_expr1.type()=ns.follow(expr.type()).subtype();
         index_expr1.array()=expr;
@@ -592,15 +683,8 @@
 
         equal_exprt equality_expr(index_expr1, index_expr2);
         
-        literalt equality_lit=convert(equality_expr);
-
-        // add constraint
-        bvt bv;
-        bv.reserve(2);
-        bv.push_back(equality_lit);
-        bv.push_back(guard_lit);
-        prop.lcnf(bv);
-      }
+        lazy_constraintt lazy(ARRAY_WIDTH, or_exprt(equality_expr,equal_exprt(index,other_index)));
+        add_array_constraint(lazy,false);
     }
   }
 }
@@ -725,7 +809,8 @@
     assert(base_type_eq(index_expr.type(), expr.op0().type(), ns));
 
     // add constraint
-    set_to_true(equal_exprt(index_expr, expr.op0()));
+    lazy_constraintt lazy(ARRAY_OF, equal_exprt(index_expr, expr.op0()));
+    add_array_constraint(lazy, false);
   }
 }
 
@@ -746,7 +831,6 @@
   const if_exprt &expr)
 {
   // we got x=(c?a:b)
-  literalt cond_lit=convert(expr.cond());
 
   // get other array index applications
   // and add c => x[i]=a[i]
@@ -772,7 +856,8 @@
     assert(index_expr1.type()==index_expr2.type());
 
     // add implication
-    prop.lcnf(!cond_lit, convert(equal_exprt(index_expr1, index_expr2)));
+    lazy_constraintt lazy(ARRAY_IF, implies_exprt(expr.cond(), equal_exprt(index_expr1, index_expr2)));
+    add_array_constraint(lazy, false);
   }
 
   // now the false case
@@ -795,6 +880,7 @@
     assert(index_expr1.type()==index_expr2.type());
 
     // add implication
-    prop.lcnf(cond_lit, convert(equal_exprt(index_expr1, index_expr2)));
+    lazy_constraintt lazy(ARRAY_IF, or_exprt(expr.cond(), equal_exprt(index_expr1, index_expr2)));
+    add_array_constraint(lazy, false);
   }
 }
Index: src/solvers/flattening/arrays.h
===================================================================
--- src/solvers/flattening/arrays.h	(revision 5264)
+++ src/solvers/flattening/arrays.h	(working copy)
@@ -66,6 +66,25 @@
   typedef std::map<unsigned, index_sett> index_mapt;
   index_mapt index_map;
   
+  // adds array constraints lazily
+  typedef enum lazy_type {ARRAY_ACKERMANN, ARRAY_WIDTH, ARRAY_IF, ARRAY_OF, ARRAY_TYPECAST} lazy_typet;
+  struct lazy_constraintt
+  {
+    lazy_typet type;
+    exprt lazy;
+
+    lazy_constraintt(lazy_typet _type, const exprt &_lazy)
+    {
+      type = _type;
+      lazy = _lazy;
+    }
+  };
+  bool lazy_arrays;
+  bool incremental_cache;
+  std::list<lazy_constraintt> lazy_array_constraints;
+  void add_array_constraint(const lazy_constraintt &lazy, bool refine = true);
+  std::map<exprt, bool> expr_map;
+
   // adds all the constraints eagerly
   void add_array_constraints();
   void add_array_Ackermann_constraints();
@@ -77,9 +96,14 @@
   void add_array_constraints_update(const index_sett &index_set, const update_exprt &expr);
   void add_array_constraints_array_of(const index_sett &index_set, const array_of_exprt &exprt);
 
-  void build_index_map();
   void update_index_map();
   void collect_arrays(const exprt &a);
+  void collect_indices();
+  void collect_indices(const exprt &a);
+
+  
+  virtual bool is_unbounded_array(const typet &type) const { assert(false); }
+    // (maybe this function should be partially moved here from boolbv)
 };
 
 #endif
Index: src/solvers/flattening/equality.h
===================================================================
--- src/solvers/flattening/equality.h	(revision 5264)
+++ src/solvers/flattening/equality.h	(working copy)
@@ -29,6 +29,7 @@
   {
     add_equality_constraints();
     prop_conv_solvert::post_process();
+    typemap.clear(); // if called incrementally, don't do it twice
   }
 
 protected:
Index: src/solvers/refinement/bv_refinement.h
===================================================================
--- src/solvers/refinement/bv_refinement.h	(revision 5264)
+++ src/solvers/refinement/bv_refinement.h	(working copy)
@@ -30,6 +30,9 @@
 
   // maximal number of times we refine a formula node
   unsigned max_node_refinement;
+  // enable/disable refinements
+  bool do_array_refinement;
+  bool do_arithmetic_refinement;
   
   using bv_pointerst::is_in_conflict;
 
Index: src/solvers/refinement/bv_refinement_loop.cpp
===================================================================
--- src/solvers/refinement/bv_refinement_loop.cpp	(revision 5264)
+++ src/solvers/refinement/bv_refinement_loop.cpp	(working copy)
@@ -28,7 +28,9 @@
 bv_refinementt::bv_refinementt(
   const namespacet &_ns, propt &_prop):
   bv_pointerst(_ns, _prop),
-  max_node_refinement(5)
+  max_node_refinement(5),
+  do_array_refinement(true),
+  do_arithmetic_refinement(true)
 {
   // check features we need
   assert(prop.has_set_assumptions());
@@ -137,7 +139,7 @@
 {
   // this puts the underapproximations into effect
   bvt assumptions = parent_assumptions;
-  
+
   for(approximationst::const_iterator
       a_it=approximations.begin();
       a_it!=approximations.end();
Index: src/solvers/refinement/refine_arithmetic.cpp
===================================================================
--- src/solvers/refinement/refine_arithmetic.cpp	(revision 5264)
+++ src/solvers/refinement/refine_arithmetic.cpp	(working copy)
@@ -81,6 +81,9 @@
 
 void bv_refinementt::convert_floatbv_op(const exprt &expr, bvt &bv)
 {
+  if(!do_arithmetic_refinement)
+    return SUB::convert_floatbv_op(expr, bv);
+  
   if(ns.follow(expr.type()).id()!=ID_floatbv ||
      expr.operands().size()!=3)
     return SUB::convert_floatbv_op(expr, bv);
@@ -102,6 +105,9 @@
 
 void bv_refinementt::convert_mult(const exprt &expr, bvt &bv)
 {
+  if(!do_arithmetic_refinement)
+    SUB::convert_mult(expr, bv);
+  
   // we catch any multiplication
   // unless it involves a constant
 
@@ -156,6 +162,9 @@
 
 void bv_refinementt::convert_div(const exprt &expr, bvt &bv)
 {
+  if(!do_arithmetic_refinement)
+    return SUB::convert_div(expr, bv);
+
   // we catch any division
   // unless it's integer division by a constant
   
@@ -181,6 +190,9 @@
 
 void bv_refinementt::convert_mod(const exprt &expr, bvt &bv)
 {
+  if(!do_arithmetic_refinement)
+    return SUB::convert_mod(expr, bv);
+
   // we catch any mod
   // unless it's integer + constant
 
Index: src/solvers/refinement/refine_arrays.cpp
===================================================================
--- src/solvers/refinement/refine_arrays.cpp	(revision 5264)
+++ src/solvers/refinement/refine_arrays.cpp	(working copy)
@@ -7,8 +7,10 @@
 \*******************************************************************/
 
 #include <util/std_expr.h>
+#include <iostream>
 
 #include "bv_refinement.h"
+#include <solvers/sat/satcheck.h>
 
 /*******************************************************************\
 
@@ -24,10 +26,15 @@
 
 void bv_refinementt::post_process_arrays()
 {
+  collect_indices();
+  // at this point all indices should in the index set
+  
   // just build the data structure
-  build_index_map();
+  update_index_map();
 
   // we don't actually add any constraints
+  lazy_arrays = do_array_refinement;
+  add_array_constraints();
 }
 
 /*******************************************************************\
@@ -44,9 +51,68 @@
 
 void bv_refinementt::arrays_overapproximated()
 {
-  // build index_map with values
-  index_mapt value_index_map;
+  if(!lazy_arrays) return;
+  
+  unsigned nb_active = 0;
 
+  std::list<lazy_constraintt>::iterator it = lazy_array_constraints.begin();
+  while(it != lazy_array_constraints.end())
+  {
+    satcheck_minisat_no_simplifiert sat_check;
+    bv_pointerst solver(ns,sat_check);
+
+    exprt current = (*it).lazy;
+
+    // some minor simplifications
+    // check if they are worth having
+    if (current.id() == ID_implies)
+    {
+      implies_exprt imp = to_implies_expr(current);
+      assert (imp.operands().size() == 2);
+      exprt implies_simplified = get(imp.op0());
+      if (implies_simplified == false_exprt()){
+	      ++it;
+	      continue;
+      }
+    }
+
+    if (current.id() == ID_or)
+    {
+      or_exprt orexp = to_or_expr(current);
+      assert (orexp.operands().size() == 2);
+      exprt o1 = get(orexp.op0());
+      exprt o2 = get(orexp.op1());
+      if (o1 == true_exprt() || o2 == true_exprt())
+      {
+	      ++it;
+	      continue;
+      }
+    }
+
+    exprt simplified = get(current);
+    solver << simplified;
+
+    switch(sat_check.prop_solve())
+    {
+      case decision_proceduret::D_SATISFIABLE:
+        ++it;
+	      break; 
+      case decision_proceduret::D_UNSATISFIABLE:
+        prop.l_set_to_true(convert(current));
+        nb_active++;
+        lazy_array_constraints.erase(it++);
+	      break;
+      default:
+	assert(false);
+    }
+
+  }
+
+  std::cout << "BV-Refinement: " << nb_active << " array expressions become active" << std::endl;
+  std::cout << "BV-Refinement: " << lazy_array_constraints.size() << " inactive array expressions" << std::endl;
+  if (nb_active > 0)
+    progress = true;
+
   #if 0
   // iterate over *roots*
   for(unsigned i=0; i<arrays.size(); i++)
